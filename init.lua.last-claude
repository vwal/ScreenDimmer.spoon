--- === ScreenDimmer ===
---
--- Automatically dims the screen after a period of inactivity
---
--- Download: [https://github.com/vwal/ScreenDimmer.spoon](https://github.com/vwal/ScreenDimmer.spoon)

local obj = {}
obj.__index = obj

-- Metadata
obj.name = "ScreenDimmer"
obj.version = "1.4"
obj.author = "Ville Walveranta <ville@walveranta.org>"
obj.homepage = "https://github.com/vwal/ScreenDimmer.spoon"
obj.license = "MIT - https://opensource.org/licenses/MIT"

-- Configuration variables
obj.idleTimeout = 300            -- Default timeout in seconds
obj.dimPercentage = 10           -- Default dim percentage
obj.logging = false              -- Default logging state
obj.fadeDuration = 0.5           -- Duration of fade effect in seconds
obj.fadeSteps = 20               -- Number of steps in the fade effect
obj.checkInterval = 10           -- Check every 10 seconds
obj.unlockGracePeriod = 5        -- Grace period after unlock (seconds)
obj.userActionGracePeriod = 2    -- Grace period after user action (seconds)

-- Internal variables
obj.originalBrightness = {}
obj.isDimmed = false
obj.isFading = false
obj.isEnabled = false
obj.stateChecker = nil
obj.userActionWatcher = nil
obj.caffeineWatcher = nil
obj.screenWakeTimer = nil
obj.lastWakeTime = 0
obj.dimmedBeforeSleep = false
obj.isInitialized = false
obj.lastUserAction = 0
obj.unlockTimer = nil
obj.screenUnlockCount = 0
obj.lockState = false
obj.lastUnlockTime = 0

-- Utility function for logging
local function log(message, force)
    if force or obj.logging then
        print(os.date("%Y-%m-%d %H:%M:%S: ") .. message)
    end
end

function obj:start(showMessage)
    if not self.isEnabled then
        self.stateChecker:start()
        self.userActionWatcher:start()
        self.caffeineWatcher:start()
        self.isEnabled = true
        
        if showMessage ~= false then
            hs.alert.show("Screen Dimmer Enabled")
            log("Screen Dimmer Enabled", true)
        end
    end
end

function obj:stop()
    if self.isEnabled then
        self.stateChecker:stop()
        self.userActionWatcher:stop()
        self.caffeineWatcher:stop()
        self.isEnabled = false
        self:restoreBrightness()
        hs.alert.show("Screen Dimmer Disabled")
        log("Screen Dimmer Disabled", true)
    end
end

function obj:toggle()
    if self.isEnabled then
        self:stop()
    else
        self:start()
    end
end

function obj:bindHotkeys(mapping)
    local spec = {
        toggle = function() self:toggle() end
    }
    hs.spoons.bindHotkeysToSpec(spec, mapping)
end

function obj:init()
    if self.isInitialized then
        return self
    end

    -- Log initial configuration
    log("Configuration at init:", true)
    log(string.format("  - idleTimeout: %s", tostring(self.idleTimeout)), true)
    log(string.format("  - dimPercentage: %s", tostring(self.dimPercentage)), true)
    log(string.format("  - logging: %s", tostring(self.logging)), true)

    -- Initialize the rest of the state variables
    self.originalBrightness = {}
    self.isDimmed = false
    self.isFading = false
    self.isEnabled = false
    self.dimmedBeforeSleep = false
    self.dimmedBeforeLock = false
    self.lockState = false
    self.lastWakeTime = hs.timer.secondsSinceEpoch()
    self.lastUserAction = self.lastWakeTime
    self.lastUnlockTime = self.lastWakeTime
    
    -- Initialize state checker timer
    self.stateChecker = hs.timer.new(self.checkInterval, function() self:checkAndUpdateState() end)

    -- Initialize user action watcher
    self.userActionWatcher = hs.eventtap.new({
        hs.eventtap.event.types.keyDown,
        hs.eventtap.event.types.leftMouseDown,
        hs.eventtap.event.types.rightMouseDown,
        hs.eventtap.event.types.mouseMoved,
        hs.eventtap.event.types.flagsChanged,
        hs.eventtap.event.types.scrollWheel
    }, function(event)
        self.lastUserAction = hs.timer.secondsSinceEpoch()
        if self.isDimmed then
            hs.timer.doAfter(0.1, function()
                self:restoreBrightness()
            end)
        end
        return false
    end)

    -- Initialize caffeine watcher with improved sleep/lock handling
    self.caffeineWatcher = hs.caffeinate.watcher.new(function(eventType)
        log("Caffeinate event: " .. eventType)
        local now = hs.timer.secondsSinceEpoch()
        
        local function restoreScreenBrightness()
            local screens = self:getAllScreens()
            for _, screen in ipairs(screens) do
                local id = screen:id()
                local targetBrightness = self.originalBrightness[id] or 0.5
                local success, err = pcall(function()
                    screen:setBrightness(targetBrightness)
                end)
                if not success then
                    log("Error setting brightness: " .. tostring(err))
                end
            end
            self.isDimmed = false
            log("Brightness explicitly restored during unlock sequence")
        end
    
        if eventType == hs.caffeinate.watcher.screensDidWakeFromSecureInput then  -- event 4
            -- Mark that we're in pre-auth wake state
            self.inPreAuthWake = true
            log("Entering pre-auth wake state")
            -- Don't restore brightness here
            
        elseif eventType == hs.caffeinate.watcher.screensDidUnlock then  -- event 11
            self.lockState = false
            self.lastUnlockTime = now
            self.lastUserAction = now
            self.inPreAuthWake = false  -- Clear pre-auth state
            
            -- Cancel any existing unlock timer
            if self.unlockTimer then
                self.unlockTimer:stop()
            end
            
            -- Temporarily pause the state checker
            if self.stateChecker then
                self.stateChecker:stop()
            end
            
            -- Set up a new unlock sequence with delay
            self.unlockTimer = hs.timer.doAfter(0.5, function()
                restoreScreenBrightness()
                self:resetState()
                
                -- Restart the state checker after a delay
                hs.timer.doAfter(self.unlockGracePeriod, function()
                    if self.stateChecker then
                        self.stateChecker:start()
                    end
                end)
            end)
            
        elseif eventType == hs.caffeinate.watcher.systemDidWake then
            self.lastWakeTime = now
            self.lastUserAction = now
            
            -- Only handle wake if not in pre-auth state
            if not self.inPreAuthWake then
                if self.stateChecker then
                    self.stateChecker:stop()
                end
                
                hs.timer.doAfter(1, function()
                    self:resetState()
                    restoreScreenBrightness()
                    
                    hs.timer.doAfter(self.unlockGracePeriod, function()
                        if self.stateChecker then
                            self.stateChecker:start()
                        end
                    end)
                end)
            end
        end
    end)
    
    -- Show initialization message and start
    log("Screen Dimmer Initialized", true)
    hs.alert.show("Screen Dimmer Initialized")
    self:start(false)
    
    self.isInitialized = true
    return self
end

function obj:configure(config)
    log("Configuring variables...", true)
    if config then
        log(".. with calling values.", true)
        self.idleTimeout = config.idleTimeout or self.idleTimeout
        self.dimPercentage = config.dimPercentage or self.dimPercentage
        self.logging = config.logging or self.logging
    end
    
    log("Configuration now:", true)
    log(string.format("  - idleTimeout: %s", tostring(self.idleTimeout)), true)
    log(string.format("  - dimPercentage: %s", tostring(self.dimPercentage)), true)
    log(string.format("  - logging: %s", tostring(self.logging)), true)

    -- If already initialized, we might need to update some internal state
    -- if self.isInitialized then
        -- Update any internal timers or state that depends on these values
        -- ...
    --end
    
    return self
end

function obj:getAllScreens()
    return hs.screen.allScreens()
end

function obj:fadeScreens(fromBrightness, toBrightness)
    if self.isFading then return end
    self.isFading = true
    
    local screens = self:getAllScreens()
    local stepDuration = self.fadeDuration / self.fadeSteps
    
    log(string.format("Fading screens from %.2f to %.2f", fromBrightness, toBrightness))
    
    for step = 1, self.fadeSteps do
        local t = step / self.fadeSteps
        local currentBrightness = fromBrightness + (toBrightness - fromBrightness) * t
        
        for _, screen in ipairs(screens) do
            local success, err = pcall(function()
                screen:setBrightness(currentBrightness)
            end)
            if not success then
                log("Error setting brightness: " .. tostring(err))
            end
        end
        
        hs.timer.usleep(stepDuration * 1000000)
    end
    
    self.isFading = false
end

function obj:dimScreens()
    if self.isDimmed or not self.isEnabled then return end
    
    local screens = self:getAllScreens()
    for _, screen in ipairs(screens) do
        local id = screen:id()
        self.originalBrightness[id] = screen:getBrightness()
    end
    
    -- Use absolute percentage instead of relative
    local toBrightness = self.dimPercentage / 100  -- Direct percentage of max brightness
    local fromBrightness = self.originalBrightness[screens[1]:id()]
    self:fadeScreens(fromBrightness, toBrightness)
    self.isDimmed = true
    self.dimmedBeforeSleep = true
    log("Screens dimmed", true)
end

function obj:restoreBrightness()
    if not self.isDimmed and not self.dimmedBeforeLock then return end
    
    local screens = self:getAllScreens()
    if next(self.originalBrightness) == nil then 
        log("No original brightness values stored")
        return 
    end
    
    log("Restoring brightness - current state: " .. hs.inspect({
        isDimmed = self.isDimmed,
        screenCount = #screens,
        originalBrightness = self.originalBrightness
    }))
    
    local fromBrightness = screens[1]:getBrightness()
    local toBrightness = self.originalBrightness[screens[1]:id()]
    self:fadeScreens(fromBrightness, toBrightness)
    
    -- Reset all state flags
    self.isDimmed = false
    self.dimmedBeforeLock = false
    self.dimmedBeforeSleep = false
    self.lastUserAction = hs.timer.secondsSinceEpoch()
    self.lastUnlockTime = self.lastUserAction
    
    -- Force an immediate state check after a small delay
    hs.timer.doAfter(0.5, function()
        self:checkAndUpdateState()
    end)
    
    log("Brightness restored", true)
end

function obj:shouldDim()
    if not self.isEnabled then return false end
    
    local now = hs.timer.secondsSinceEpoch()
    local idleTime = now - self.lastUserAction
    local timeSinceUnlock = now - self.lastUnlockTime
    
    -- Check if we're in the grace period after unlock
    if timeSinceUnlock < self.unlockGracePeriod then
        log(string.format("In unlock grace period (%.1f seconds since unlock)", timeSinceUnlock))
        return false
    end
    
    -- Check if we're past the idle timeout
    if idleTime >= self.idleTimeout then
        log(string.format("Idle time (%.1f seconds) exceeds timeout", idleTime))
        return true
    end
    
    return false
end

function obj:checkAndUpdateState()
    local now = hs.timer.secondsSinceEpoch()
    local timeSinceUnlock = now - (self.lastUnlockTime or 0)
    local idleTime = hs.host.idleTime()
   
    if timeSinceUnlock < self.unlockGracePeriod then
        log(string.format("In unlock grace period (%.1f seconds since unlock)", timeSinceUnlock))
        return
    end

    -- Determine if screen should be dimmed based on idle time
    local shouldDim = idleTime > self.idleTimeout
    if shouldDim and idleTime then
        log(string.format("Idle time (%.1f seconds) exceeds timeout", idleTime))
    end
    
    log(string.format("Checking state - Should dim: %s, Currently dimmed: %s", 
        tostring(shouldDim), tostring(self.isDimmed)))
    
    -- Handle state changes
    if shouldDim and not self.isDimmed then
        self:dimScreens()
    elseif not shouldDim and self.isDimmed then
        self:restoreBrightness()
    end
end

function obj:handleWakeEvent()
    log("Handling wake event")
    self.lastWakeTime = hs.timer.secondsSinceEpoch()
    
    -- If screen was dimmed before sleep, restore brightness
    if self.dimmedBeforeSleep then
        hs.timer.doAfter(0.5, function()
            self:restoreBrightness()
        end)
    end
end

function obj:resetState()
    self.isDimmed = false
    self.isFading = false
    self.dimmedBeforeSleep = false
    self.dimmedBeforeLock = false
    self.originalBrightness = {}
    self.lastUserAction = hs.timer.secondsSinceEpoch()
    self.lastUnlockTime = self.lastUserAction
    self.lastWakeTime = self.lastUserAction
    log("State reset completed")
end

return obj
